#version 310 es

#define WORK_GROUP_SIZE ${common.texture_work_group_size}

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE, local_size_z = 1) in;
layout(std430) buffer;

layout(rgba32f, binding = ${spatial_buffer.last_frame}) uniform highp image2D last_frame_texture;
layout(rgba32f, binding = ${common.spatial_buffer_current_frame}) uniform highp image2D current_frame_texture;
layout(rgba32f, binding = ${common.spatial_buffer}) uniform highp image2D spatial_buffer_texture;


#define STABILITY_PER_FRAME float(${spatial_buffer.stability_per_frame})
#define Z_DELTA_THRESHOLD float(${spatial_buffer.z_delta_threshold})
#define MINOR_MOVE_FILTER_FACTOR float(${spatial_buffer.minor_move_filter_factor})
#define MINOR_MOVE_FILTER_MIN float(${spatial_buffer.minor_move_filter_min})
#define MINOR_MOVE_FILTER_MAX float(${spatial_buffer.minor_move_filter_max})
#define MINOR_MOVE_FILTER_EDGE_WEIGHT float(${spatial_buffer.minor_move_filter_edge_weight})

#include "common.inc"
#include "raytrace/camera.inc"


void main() {
    // get pixel and discard excess ones
    ivec2 image_size = imageSize(spatial_buffer_texture);
    ivec2 pixel_pos = ivec2(gl_GlobalInvocationID.xy);
    if (pixel_pos.x >= image_size.x || pixel_pos.y >= image_size.y) {
        return;
    }

    // world space position, that was in this pixel on last frame
    vec3 last_position = imageLoad(last_frame_texture, pixel_pos).xyz;

    // screen space position, that was here on the last frame
    dvec3 last_screen_position = worldPositionToScreen(dvec3(last_position));

    // convert screen space position to pixel position
    vec2 last_pixel_position_f = vec2((last_screen_position.xy * .5 + .5) * dvec2(image_size));
    ivec2 last_pixel_position = ivec2(last_pixel_position_f);

    // position is moved out of screen
    if (last_pixel_position.x < 0 || last_pixel_position.y < 0 || last_pixel_position.x >= image_size.x || last_pixel_position.y >= image_size.y) {
        return;
    }

    // get current world position of the same pixel
    vec3 current_position = imageLoad(current_frame_texture, pixel_pos).xyz;

    // get absolute and relative z-value difference
    float absolute_z_delta = getDistanceToCamera(current_position) - float(last_screen_position.z);
    float relative_z_delta = absolute_z_delta / float(last_screen_position.z);

    // calculate stability decrease, based on z difference and movement on screen
    float maximum_stability_value;
    if (relative_z_delta > Z_DELTA_THRESHOLD) {
        // if distance delta is more than threshold, set temporal stability to zero
        maximum_stability_value = 0.0;
    } else {
        // -- MINOR MOVE FILTER --
        // Decrease stability of slightly moved pixels to remove artifacts,
        // caused by edge of large region moved by, for example by 1 pixel, colliding with another region,
        // moved for 2 pixels. For larger move values such regions are small and edges are not visible.
        vec2 move = (vec2(pixel_pos) + .5 - last_pixel_position_f.xy);
        float move_factor = max(abs(move.x), abs(move.y));
        if (move_factor < MINOR_MOVE_FILTER_MIN) {
            maximum_stability_value = 1.0;
        } else {
            vec2 edge_factor_v = abs(0.5 - fract(last_pixel_position_f)) * 2.0;
            float edge_factor = mix(1.0, max(edge_factor_v.x, edge_factor_v.y), MINOR_MOVE_FILTER_EDGE_WEIGHT);
            move_factor += 1.0;
            move_factor /= MINOR_MOVE_FILTER_MAX;
            move_factor -= .5;
            maximum_stability_value = 1.0 - clamp(1.0 - 4.0 * move_factor * move_factor, 0.0, 1.0) * MINOR_MOVE_FILTER_FACTOR * edge_factor;
        }
    }

    vec4 spatial_buffer_data = imageLoad(spatial_buffer_texture, last_pixel_position);
    if (spatial_buffer_data.x < 0.0) {
        spatial_buffer_data.w = min(maximum_stability_value, spatial_buffer_data.w + STABILITY_PER_FRAME);
    }
    spatial_buffer_data.z = 1.0 - maximum_stability_value;
    spatial_buffer_data.xy = vec2(pixel_pos) + 0.999 - fract(last_pixel_position_f) * 0.998;
    imageStore(spatial_buffer_texture, last_pixel_position, spatial_buffer_data);
}