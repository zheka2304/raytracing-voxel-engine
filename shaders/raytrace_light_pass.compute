#version 310 es

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
layout(std430) buffer;

precision highp float;
precision highp int;

//

// INITIAL_PASS must be defined for first pass, that initializes direct light & initial rays from point lights
#define LIGHT_REFLECTION_COUNT 4

//

layout(binding = 3) readonly buffer RenderBuffer {
    uint data[];
} render_buffer;

layout(binding = 4) readonly buffer BufferOffsets {
    int data[];
} buffer_offsets;

layout(binding = 5) readonly buffer RenderRegion {
    ivec3 offset;
    ivec3 count;
} render_region;

layout(binding = 6) readonly buffer AmbientData {
    vec4 direct_light_color;
    vec3 direct_light_ray;
    vec4 ambient_light_color;
} ambient_data;

layout(binding = 12) buffer LightBuffer {
    uint data[];
} light_pass_buffer;

layout(binding = 13) buffer LightPassOffsetsBuffer {
    ivec3 region_offset;   // chunk region offset
    ivec3 region_size;     // chunk region size
    int offsets[];         // chunk offsets by chunk position
} light_pass_offsets;

struct LightJob {
    int level;
    ivec3 chunk_position;
    int buffer_offset;
    int buffer_reg_size;
    int buffer_stride;
};

layout(binding = 14) buffer LightPassJobsBuffer {
    LightJob jobs[];
} light_pass_jobs;


// -- raytracing --

#define PI 3.1415926

struct RaytraceData {
    vec3 start;
    vec3 ray;
    vec3 rayS;
    vec3 rayL;
    float distance;
    float distance_offset;
    int voxel_distance;
    ivec3 pos;
    ivec3 pos_step;
};

struct RegTraverseData {
    vec3 add_f;
    ivec3 add_i;
    int region_end;
};

struct Ray {
    vec3 start;
    vec3 ray;
    float max_distance;
    int max_steps;
};

struct RayResult {
    uint voxel;
    int steps;
    float distance;
    int voxel_distance;
    vec3 end;
    vec3 voxel_normal;
};


#define BINARY_CHOICE_AB_A(A, B) A
#define BINARY_CHOICE_AB_B(A, B) B

#define RAYTRACE_DDA_STEP(RAYTRACE_DATA, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
    { \
        bvec3 _mask = lessThanEqual(RAYTRACE_DATA.rayL, min(RAYTRACE_DATA.rayL.yzx, RAYTRACE_DATA.rayL.zxy)); \
        RAYTRACE_DATA.rayL += vec3(_mask) * RAYTRACE_DATA.rayS; \
        RAYTRACE_DATA.pos += ivec3(_mask) * RAYTRACE_DATA.pos_step; \
        RAYTRACE_DATA.voxel_distance++; \
    }


#define PREPARE_TO_TRAVERSE_REGION(RAYTRACE_DATA, DATA_VAR, REGION_SIZE, REGION_SIZE_BIT_MASK, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
    { \
        ivec3 COUNT_ = ivec3( \
            IS_RAY_X_POSITIVE(REGION_SIZE - (RAYTRACE_DATA.pos.x & REGION_SIZE_BIT_MASK), (RAYTRACE_DATA.pos.x & REGION_SIZE_BIT_MASK) + 1),  \
            IS_RAY_Y_POSITIVE(REGION_SIZE - (RAYTRACE_DATA.pos.y & REGION_SIZE_BIT_MASK), (RAYTRACE_DATA.pos.y & REGION_SIZE_BIT_MASK) + 1),  \
            IS_RAY_Z_POSITIVE(REGION_SIZE - (RAYTRACE_DATA.pos.z & REGION_SIZE_BIT_MASK), (RAYTRACE_DATA.pos.z & REGION_SIZE_BIT_MASK) + 1)  \
        ); \
        \
        vec3 _rayL_ = RAYTRACE_DATA.rayL + RAYTRACE_DATA.rayS * vec3(COUNT_ - 1); \
        \
        vec2 _add_yz = (_rayL_.x - RAYTRACE_DATA.rayL.yz) / RAYTRACE_DATA.rayS.yz; \
        vec2 _add_xz = (_rayL_.y - RAYTRACE_DATA.rayL.xz) / RAYTRACE_DATA.rayS.xz; \
        vec2 _add_xy = (_rayL_.z - RAYTRACE_DATA.rayL.xy) / RAYTRACE_DATA.rayS.xy; \
        \
        ivec3 _add_i_1 = max(ivec3(0), ivec3(ceil(vec3(_add_yz.x, _add_xz.x, _add_xy.x)))); \
        ivec3 _add_i_2 = max(ivec3(0), ivec3(ceil(vec3(_add_yz.y, _add_xz.y, _add_xy.y)))); \
        \
        ivec3 _dis_ = _add_i_1 + _add_i_2 + COUNT_;  \
        \
        if (_dis_.x < _dis_.y) {  \
            if (_dis_.z < _dis_.x) { \
                DATA_VAR.add_i = ivec3(_add_i_1.z, _add_i_2.z, COUNT_.z); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.z; \
            } else { \
                DATA_VAR.add_i = ivec3(COUNT_.x, _add_i_1.x, _add_i_2.x); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.x; \
            } \
        } else { \
            if (_dis_.z < _dis_.y) { \
                DATA_VAR.add_i = ivec3(_add_i_1.z, _add_i_2.z, COUNT_.z); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.z; \
            } else { \
                DATA_VAR.add_i = ivec3(_add_i_1.y, COUNT_.y, _add_i_2.y); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.y; \
            } \
        } \
    }

#define DO_TRAVERSE_REGION(RAYTRACE_DATA, DATA_VAR, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
    { \
        RAYTRACE_DATA.rayL += vec3(DATA_VAR.add_i) * RAYTRACE_DATA.rayS; \
        RAYTRACE_DATA.pos += DATA_VAR.add_i * RAYTRACE_DATA.pos_step; \
        RAYTRACE_DATA.voxel_distance = DATA_VAR.region_end; \
    }

#define NOT_TRAVERSE_REGION_END(RAYTRACE_DATA, DATA_VAR) RAYTRACE_DATA.voxel_distance < DATA_VAR.region_end

#define EXTRACT_RAYTRACE_DISTANCE_AND_SIDE(RAYTRACE_DATA, RESULT_VAR, SIDE_VAR) \
    { \
        vec3 _lastRayL = RAYTRACE_DATA.rayL - RAYTRACE_DATA.rayS; \
        RESULT_VAR = max(_lastRayL.x, max(_lastRayL.y, _lastRayL.z)); \
        if (_lastRayL.x > _lastRayL.y) { \
            if (_lastRayL.x > _lastRayL.z) { \
                RESULT_VAR = RAYTRACE_DATA.distance_offset + _lastRayL.x; \
                SIDE_VAR = vec3(-RAYTRACE_DATA.pos_step.x, 0, 0); \
            } else { \
                RESULT_VAR = RAYTRACE_DATA.distance_offset + _lastRayL.z; \
                SIDE_VAR = vec3(0, 0, -RAYTRACE_DATA.pos_step.z); \
            } \
        } else { \
            if (_lastRayL.y > _lastRayL.z) { \
                RESULT_VAR = RAYTRACE_DATA.distance_offset + _lastRayL.y; \
                SIDE_VAR = vec3(0, -RAYTRACE_DATA.pos_step.y, 0); \
            } else { \
                RESULT_VAR = RAYTRACE_DATA.distance_offset + _lastRayL.z; \
                SIDE_VAR = vec3(0, 0, -RAYTRACE_DATA.pos_step.z); \
            } \
        } \
    }

#define MAIN_RAYTRACE_FUNC_PRE_RAYTRACE_EXIT \
    result.voxel = 1u; \
    result.steps = i; \
    EXTRACT_RAYTRACE_DISTANCE_AND_SIDE(raytrace_data, result.distance, result.voxel_normal); \
    return result; \

#define MAIN_RAYTRACE_FUNC(FUNC_NAME, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
RayResult FUNC_NAME(RaytraceData raytrace_data, int max_steps, int max_distance) { \
    RegTraverseData tier1_region; \
    RegTraverseData tier2_region; \
    RegTraverseData chunk_region; \
    \
    RayResult result; \
    result.distance = 0.0; \
    result.voxel_normal = vec3(0.0); \
    result.voxel = 0u; \
    result.voxel_distance = 0; \
    \
    int i = 0; \
    while(i < max_steps) { \
        ivec3 chunk_pos = raytrace_data.pos >> 7; \
        ivec3 chunk_pos_off = chunk_pos - render_region.offset; \
        \
        if (raytrace_data.voxel_distance > max_distance) { \
            result.steps = i; \
            result.distance = float(max_distance); \
            result.voxel_distance = raytrace_data.voxel_distance; \
            return result; \
        } \
        \
        PREPARE_TO_TRAVERSE_REGION(raytrace_data, chunk_region, 128, 127, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); \
        /* if in bound of chunk, raytrace it */ \
        if (chunk_pos_off.x >= 0 && chunk_pos_off.y >= 0 && chunk_pos_off.z >= 0 && chunk_pos_off.x < render_region.count.x && chunk_pos_off.y < render_region.count.y && chunk_pos_off.z < render_region.count.z) { \
            /* get buffer offset from chunk */ \
            int chunk_buffer_offset = buffer_offsets.data[chunk_pos_off.x + (chunk_pos_off.z + chunk_pos_off.y * render_region.count.z) * render_region.count.x]; \
            /* iterate while inside this chunk */ \
            while (i < max_steps) { \
                if (NOT_TRAVERSE_REGION_END(raytrace_data, chunk_region)) { \
                    /* raytrace over tier 2 region */ \
                    ivec3 r2pos = (raytrace_data.pos >> 4) & 7; \
                    int r2offset = chunk_buffer_offset + (r2pos.x | ((r2pos.z | (r2pos.y << 3)) << 3)) * 4161; \
                    \
                    if (raytrace_data.voxel_distance > max_distance) { \
                        result.steps = i; \
                        result.distance = float(max_distance); \
                        result.voxel_distance = raytrace_data.voxel_distance; \
                        return result; \
                    } \
                    \
                    PREPARE_TO_TRAVERSE_REGION(raytrace_data, tier2_region, 16, 15, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); \
                    if (render_buffer.data[r2offset] != 0u) { \
                        /* region is non-empty, raytrace over tier 1 */ \
                        while (NOT_TRAVERSE_REGION_END(raytrace_data, tier2_region)) { \
                            /* raytrace over tier 1 region */ \
                            ivec3 r1pos = (raytrace_data.pos >> 2) & 3; \
                            int r1offset = r2offset + 1 + (r1pos.x | ((r1pos.z | (r1pos.y << 2)) << 2)) * 65; \
                            \
                            PREPARE_TO_TRAVERSE_REGION(raytrace_data, tier1_region, 4, 3, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); \
                            if (render_buffer.data[r1offset] != 0u) { \
                                MAIN_RAYTRACE_FUNC_PRE_RAYTRACE_EXIT\
                                /* region is non-empty, raytrace over voxels */ \
                                while (NOT_TRAVERSE_REGION_END(raytrace_data, tier1_region)) { \
                                    ivec3 voxel_pos = raytrace_data.pos & 3; \
                                    int voxel_index = r1offset + 1 + (voxel_pos.x | ((voxel_pos.z | (voxel_pos.y << 2)) << 2)); \
                                    uint voxel = render_buffer.data[voxel_index]; \
                                    if (voxel != 0u) { \
                                        /* voxel found, end iteration */ \
                                        result.steps = i; \
                                        result.voxel = voxel; \
                                        result.voxel_distance = raytrace_data.voxel_distance; \
                                        EXTRACT_RAYTRACE_DISTANCE_AND_SIDE(raytrace_data, result.distance, result.voxel_normal); \
                                        return result; \
                                    } \
                                    /* make voxel step */ \
                                    RAYTRACE_DDA_STEP(raytrace_data, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
                                } \
                            } else { \
                                /* region is empty, skip (make tier 1 step) */ \
                                DO_TRAVERSE_REGION(raytrace_data, tier1_region, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
                            } \
                        } \
                    } else { \
                        /* region is empty, skip (make tier 2 step) */ \
                        DO_TRAVERSE_REGION(raytrace_data, tier2_region, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
                    } \
                } else { \
                    i++; \
                    break; \
                } \
            } \
        } else { \
            DO_TRAVERSE_REGION(raytrace_data, chunk_region, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
        } \
    } \
    EXTRACT_RAYTRACE_DISTANCE_AND_SIDE(raytrace_data, result.distance, result.voxel_normal); \
    result.steps = max_steps; \
    result.voxel_distance = raytrace_data.voxel_distance; \
    return result; \
}

MAIN_RAYTRACE_FUNC(raytrace_next_px_py_pz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_py_pz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_px_ny_pz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_ny_pz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_px_py_nz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_py_nz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B)
MAIN_RAYTRACE_FUNC(raytrace_next_px_ny_nz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_ny_nz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B)


#define RAYTRACE_FUNC_CALL(RESULT_VAR, RAYTRACE_DATA, PARAMS) \
    if (RAYTRACE_DATA.ray.x > 0.0) { \
        if (RAYTRACE_DATA.ray.y > 0.0) { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_px_py_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_px_py_nz PARAMS; \
            } \
        } else { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_px_ny_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_px_ny_nz PARAMS; \
            } \
        } \
    } else { \
        if (RAYTRACE_DATA.ray.y > 0.0) { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_nx_py_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_nx_py_nz PARAMS; \
            } \
        } else { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_nx_ny_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_nx_ny_nz PARAMS; \
            } \
        } \
    }


RayResult raytrace_direct(Ray ray_data, float ray_offset_dis) {
    RaytraceData raytrace_data;
    raytrace_data.ray = ray_data.ray = normalize(ray_data.ray);
    ray_data.start += ray_offset_dis * ray_data.ray;
    raytrace_data.start = ray_data.start;
    raytrace_data.voxel_distance = 0;

    vec3 r2 = ray_data.ray * ray_data.ray;
    raytrace_data.rayS = vec3(
        sqrt(1.0 + r2.y / r2.x + r2.z / r2.x),
        sqrt(1.0 + r2.x / r2.y + r2.z / r2.y),
        sqrt(1.0 + r2.x / r2.z + r2.y / r2.z)
    );

    raytrace_data.pos = ivec3(floor(ray_data.start));
    raytrace_data.pos_step = ivec3(ray_data.ray.x > 0.0 ? 1 : -1, ray_data.ray.y > 0.0 ? 1 : -1, ray_data.ray.z > 0.0 ? 1 : -1);
    raytrace_data.distance = raytrace_data.distance_offset = ray_offset_dis;

    raytrace_data.rayL = vec3(
            (ray_data.ray.x > 0.0 ? (float(raytrace_data.pos.x + 1) - ray_data.start.x) : (ray_data.start.x - float(raytrace_data.pos.x))) * raytrace_data.rayS.x,
            (ray_data.ray.y > 0.0 ? (float(raytrace_data.pos.y + 1) - ray_data.start.y) : (ray_data.start.y - float(raytrace_data.pos.y))) * raytrace_data.rayS.y,
            (ray_data.ray.z > 0.0 ? (float(raytrace_data.pos.z + 1) - ray_data.start.z) : (ray_data.start.z - float(raytrace_data.pos.z))) * raytrace_data.rayS.z
        );

    RayResult result;

    float voxel_distance_factor = abs(ray_data.ray.x) + abs(ray_data.ray.y) + abs(ray_data.ray.z);
    RAYTRACE_FUNC_CALL(result, raytrace_data, (raytrace_data, ray_data.max_steps, int((ray_data.max_distance - ray_offset_dis) * voxel_distance_factor)));
    result.end = ray_data.start + ray_data.ray * (result.distance - ray_offset_dis);
    return result;
}

//

uint color_to_uint(vec4 color) {
    uvec4 c = uvec4(clamp(color, 0.0, 1.0) * 255.5);
    return (c.r << 24) | (c.g << 16) | (c.b << 8) | c.a;
}

void main() {
    LightJob job = light_pass_jobs.jobs[gl_GlobalInvocationID.y];
    int voxel_index = int(gl_GlobalInvocationID.x);
    ivec3 voxel_pos = ivec3(voxel_index & 31, voxel_index >> 10, (voxel_index >> 5) & 31) + job.chunk_position * 32;
    vec3 voxel_center = vec3(voxel_pos * 4) + vec3(2.0, 2.0, 2.0);

    RayResult shadow_ray_result = raytrace_direct(Ray(voxel_center, -ambient_data.direct_light_ray, 100.0, 100), 0.0);

    light_pass_buffer.data[(job.buffer_offset + voxel_index) * LIGHT_REFLECTION_COUNT] = shadow_ray_result.voxel == 0u ? 0xFF0000FFu : 0u;// color_to_uint(vec4(vec3(job.chunk_position & 3) / 4.0, 1.0));// voxel_index % 3 == 0 ? 0xFF00FFAAu : 0x00FF00AAu;
}