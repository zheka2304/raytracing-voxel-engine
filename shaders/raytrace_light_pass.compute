#version 310 es

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
layout(std430) buffer;

precision highp float;
precision highp int;

//

// Amount of data units per light voxel, must be even
#define LIGHT_DATA_UNIT_COUNT 8
#define LIGHT_LEVEL_COUNT 2//((LIGHT_DATA_UNIT_COUNT - 2) / 2)

// Light voxel data structure:
// index 0 - cached technical data, like blocked neighbour count, it is calculated on initial pass
// index 1, 2 - initial light value, calculated from sky & point lights
// indices [3; LIGHT_DATA_UNIT_COUNT - 2] - at each index pair i * 2 + 1, i * 2 + 2, where i is level from 1 to (LIGHT_DATA_UNIT_COUNT - 1) / 2
// we store light value, that calculated by casting rays from values at level i - 1
// index LIGHT_DATA_UNIT_COUNT - 1 - final value of the color

// Light value structure:
// Consist of 2 integers with packed values RG and BA, all of the components are 16 bit size.a
// We store non-normalized color structure, that takes 2 integers per value, but can be blended using atomicAdd,
// so it can be done by casting rays from every source directly, not worrying about multiple threads blending one voxel color

// technical data structure:
// bits [0; 4] - blocked neighbour count (values are 0 - 27)
// bits [5; 16] - for light level i (0 for initial light level), bit i + 5 is 1, when this light voxel
//                is in range of any light source of level i and must be processed on level i + 1, and 0 otherwise


layout(binding = 3) readonly buffer RenderBuffer {
    uint data[];
} render_buffer;

layout(binding = 4) readonly buffer BufferOffsets {
    int data[];
} buffer_offsets;

layout(binding = 5) readonly buffer RenderRegion {
    ivec3 offset;
    ivec3 count;
} render_region;

layout(binding = 6) readonly buffer AmbientData {
    vec4 direct_light_color;
    vec3 direct_light_ray;
    vec4 ambient_light_color;
} ambient_data;

layout(binding = 12) buffer LightBuffer {
    uint data[];
} light_pass_buffer;

layout(binding = 13) buffer LightPassOffsetsBuffer {
    ivec3 region_offset;   // chunk region offset
    ivec3 region_size;     // chunk region size
    int offsets[];         // chunk offsets by chunk position
} light_pass_offsets;

struct LightJob {
    int level;
    ivec3 chunk_position;
    int buffer_offset;
    int buffer_reg_size;
    int buffer_stride;
};

layout(binding = 14) buffer LightPassJobsBuffer {
    LightJob jobs[];
} light_pass_jobs;


// -- raytracing --

#define PI 3.1415926

struct RaytraceData {
    vec3 start;
    vec3 ray;
    vec3 rayS;
    vec3 rayL;
    float distance;
    float distance_offset;
    int voxel_distance;
    ivec3 pos;
    ivec3 pos_step;
};

struct RegTraverseData {
    vec3 add_f;
    ivec3 add_i;
    int region_end;
};

struct Ray {
    vec3 start;
    vec3 ray;
    float max_distance;
    int max_steps;
};

#define RAY_RESULT_MAX_INTERSECTS 8

struct RayResultIntersect {
    ivec3 region_pos;   // position of tier 1 region
    // vec3 voxel_normal;  // normal of the region side
    float weight;       // weight of the contents of given region
    float distance;     // distance - length of ray segment, intersecting this region
};

struct RayResult {
    int steps;
    float distance;
    int voxel_distance;

    RayResultIntersect intersections[RAY_RESULT_MAX_INTERSECTS];
    int intersection_count;
};


#define BINARY_CHOICE_AB_A(A, B) A
#define BINARY_CHOICE_AB_B(A, B) B

// This will make simple DDA algorithm step using given RaytraceData variable.
#define RAYTRACE_DDA_STEP(RAYTRACE_DATA, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
    { \
        bvec3 _mask = lessThanEqual(RAYTRACE_DATA.rayL, min(RAYTRACE_DATA.rayL.yzx, RAYTRACE_DATA.rayL.zxy)); \
        RAYTRACE_DATA.rayL += vec3(_mask) * RAYTRACE_DATA.rayS; \
        RAYTRACE_DATA.pos += ivec3(_mask) * RAYTRACE_DATA.pos_step; \
        RAYTRACE_DATA.voxel_distance++; \
    }

// Used in lighting approximate raytracing. Gets RaytraceData and RayResult, makes simple DDA algorithm step and
// records it as intersection into RayResult, saving its position, weight and length of intersection section.
#define RAYTRACE_DDA_STEP_AND_RECORD(RAYTRACE_DATA, RESULT, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
    { \
        \
        ivec3 _region_pos = RAYTRACE_DATA.pos; \
        vec3 _lastRayL1 = RAYTRACE_DATA.rayL - RAYTRACE_DATA.rayS; \
        float distance1 = max(_lastRayL1.x, max(_lastRayL1.y, _lastRayL1.z)); \
        RAYTRACE_DDA_STEP(RAYTRACE_DATA, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); \
        vec3 _lastRayL2 = RAYTRACE_DATA.rayL - RAYTRACE_DATA.rayS; \
        float distance2 = max(_lastRayL2.x, max(_lastRayL2.y, _lastRayL2.z)); \
        \
        RESULT.intersections[RESULT.intersection_count++] = RayResultIntersect(_region_pos, 1.0, distance2 - distance1); \
        \
        if (RESULT.intersection_count >= RAY_RESULT_MAX_INTERSECTS) { \
            return RESULT; \
        } \
    }

// This will get RaytraceData and prepare given RegTraverseData to step over (step out of) region of given size,
// it is used to skip empty regions during raytracing.
//
// NOTE and TODO: This algorithm has an error state, when step will end up in region, diagonally aligned to the current one. An example is shown
// below, ray is travelling from region C and must end up in region B, but in this case it might remain in region C and then reach max_step limit without result.
// This is currently fixed by adjusting start position of the ray, so it will not start in region center, but must be fixed in some way in the future.
//
// +----+----+
// |A   |B/  |
// |    |/   |
// +----+----+
// |C  /|D   |
// |  / |    |
// +----+----+
#define PREPARE_TO_TRAVERSE_REGION(RAYTRACE_DATA, DATA_VAR, REGION_SIZE, REGION_SIZE_BIT_MASK, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
    { \
        ivec3 COUNT_ = ivec3( \
            IS_RAY_X_POSITIVE(REGION_SIZE - (RAYTRACE_DATA.pos.x & REGION_SIZE_BIT_MASK), (RAYTRACE_DATA.pos.x & REGION_SIZE_BIT_MASK) + 1),  \
            IS_RAY_Y_POSITIVE(REGION_SIZE - (RAYTRACE_DATA.pos.y & REGION_SIZE_BIT_MASK), (RAYTRACE_DATA.pos.y & REGION_SIZE_BIT_MASK) + 1),  \
            IS_RAY_Z_POSITIVE(REGION_SIZE - (RAYTRACE_DATA.pos.z & REGION_SIZE_BIT_MASK), (RAYTRACE_DATA.pos.z & REGION_SIZE_BIT_MASK) + 1)  \
        ); \
        \
        vec3 _rayL_ = RAYTRACE_DATA.rayL + RAYTRACE_DATA.rayS * vec3(COUNT_ - 1); \
        \
        vec2 _add_yz = (_rayL_.x - RAYTRACE_DATA.rayL.yz) / RAYTRACE_DATA.rayS.yz; \
        vec2 _add_xz = (_rayL_.y - RAYTRACE_DATA.rayL.xz) / RAYTRACE_DATA.rayS.xz; \
        vec2 _add_xy = (_rayL_.z - RAYTRACE_DATA.rayL.xy) / RAYTRACE_DATA.rayS.xy; \
        \
        ivec3 _add_i_1 = max(ivec3(0), ivec3(ceil(vec3(_add_yz.x, _add_xz.x, _add_xy.x)))); \
        ivec3 _add_i_2 = max(ivec3(0), ivec3(ceil(vec3(_add_yz.y, _add_xz.y, _add_xy.y)))); \
        \
        ivec3 _dis_ = _add_i_1 + _add_i_2 + COUNT_;  \
        \
        if (_dis_.x < _dis_.y) {  \
            if (_dis_.z < _dis_.x) { \
                DATA_VAR.add_i = ivec3(_add_i_1.z, _add_i_2.z, COUNT_.z); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.z; \
            } else { \
                DATA_VAR.add_i = ivec3(COUNT_.x, _add_i_1.x, _add_i_2.x); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.x; \
            } \
        } else { \
            if (_dis_.z < _dis_.y) { \
                DATA_VAR.add_i = ivec3(_add_i_1.z, _add_i_2.z, COUNT_.z); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.z; \
            } else { \
                DATA_VAR.add_i = ivec3(_add_i_1.y, COUNT_.y, _add_i_2.y); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.y; \
            } \
        } \
    }

// Makes a step, prepared by PREPARE_TO_TRAVERSE_REGION for given RaytraceData and RegTraverseData.
#define DO_TRAVERSE_REGION(RAYTRACE_DATA, DATA_VAR, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
    { \
        RAYTRACE_DATA.rayL += vec3(DATA_VAR.add_i) * RAYTRACE_DATA.rayS; \
        RAYTRACE_DATA.pos += DATA_VAR.add_i * RAYTRACE_DATA.pos_step; \
        RAYTRACE_DATA.voxel_distance = DATA_VAR.region_end; \
    }

// Returns, if currently given RaytraceData has not reached end of the region, prepared by PREPARE_TO_TRAVERSE_REGION for given RegTraverseData.
// Used fast-check end of iteration of prepared region.
#define NOT_TRAVERSE_REGION_END(RAYTRACE_DATA, DATA_VAR) RAYTRACE_DATA.voxel_distance < DATA_VAR.region_end


// Main raytracing logic, uses a macro to remove ifs, checking if ray.x/y/z is positive and instead generate 8 combinations of same function.
#define MAIN_RAYTRACE_FUNC(FUNC_NAME, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
RayResult FUNC_NAME(RaytraceData raytrace_data, int max_steps, int max_distance) { \
    RegTraverseData tier2_region; \
    RegTraverseData chunk_region; \
    \
    RayResult result; \
    result.distance = 0.0; \
    result.intersection_count = 0; \
    result.voxel_distance = 0; \
    \
    int i = 0; \
    while(i < max_steps) { \
        ivec3 chunk_pos = raytrace_data.pos >> 5; \
        ivec3 chunk_pos_off = chunk_pos - render_region.offset; \
        \
        if (raytrace_data.voxel_distance > max_distance) { \
            result.steps = i; \
            result.distance = float(max_distance); \
            result.voxel_distance = raytrace_data.voxel_distance; \
            return result; \
        } \
        \
        PREPARE_TO_TRAVERSE_REGION(raytrace_data, chunk_region, 32, 31, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); \
        /* if in bound of chunk, raytrace it */ \
        if (chunk_pos_off.x >= 0 && chunk_pos_off.y >= 0 && chunk_pos_off.z >= 0 && chunk_pos_off.x < render_region.count.x && chunk_pos_off.y < render_region.count.y && chunk_pos_off.z < render_region.count.z) { \
            /* get buffer offset from chunk */ \
            int chunk_buffer_offset = buffer_offsets.data[chunk_pos_off.x + (chunk_pos_off.z + chunk_pos_off.y * render_region.count.z) * render_region.count.x]; \
            /* iterate while inside this chunk */ \
            while (i < max_steps) { \
                if (NOT_TRAVERSE_REGION_END(raytrace_data, chunk_region)) { \
                    /* raytrace over tier 2 region */ \
                    ivec3 r2pos = (raytrace_data.pos >> 2) & 7; \
                    int r2offset = chunk_buffer_offset + (r2pos.x | ((r2pos.z | (r2pos.y << 3)) << 3)) * 4161; \
                    \
                    if (raytrace_data.voxel_distance > max_distance) { \
                        result.steps = i; \
                        result.distance = float(max_distance); \
                        result.voxel_distance = raytrace_data.voxel_distance; \
                        return result; \
                    } \
                    \
                    PREPARE_TO_TRAVERSE_REGION(raytrace_data, tier2_region, 4, 3, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); \
                    if (render_buffer.data[r2offset] != 0u) { \
                        /* region is non-empty, raytrace over tier 1 */ \
                        while (NOT_TRAVERSE_REGION_END(raytrace_data, tier2_region)) { \
                            /* raytrace over tier 1 region */ \
                            ivec3 r1pos = (raytrace_data.pos) & 3; \
                            int r1offset = r2offset + 1 + (r1pos.x | ((r1pos.z | (r1pos.y << 2)) << 2)) * 65; \
                            \
                            if (render_buffer.data[r1offset] != 0u) { \
                                RAYTRACE_DDA_STEP_AND_RECORD(raytrace_data, result, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
                            } else { \
                                /* region is empty, skip (make tier 1 step) */ \
                                RAYTRACE_DDA_STEP(raytrace_data, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
                            } \
                        } \
                    } else { \
                        /* region is empty, skip (make tier 2 step) */ \
                        DO_TRAVERSE_REGION(raytrace_data, tier2_region, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
                    } \
                } else { \
                    i++; \
                    break; \
                } \
            } \
        } else { \
            DO_TRAVERSE_REGION(raytrace_data, chunk_region, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
        } \
    } \
    vec3 _voxel_normal; \
    result.steps = max_steps; \
    result.voxel_distance = raytrace_data.voxel_distance; \
    return result; \
}

MAIN_RAYTRACE_FUNC(raytrace_next_px_py_pz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_py_pz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_px_ny_pz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_ny_pz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_px_py_nz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_py_nz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B)
MAIN_RAYTRACE_FUNC(raytrace_next_px_ny_nz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_ny_nz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B)


// Caller for main raytrace func, which checks sign all ray components once and then calls appropriate function
#define RAYTRACE_FUNC_CALL(RESULT_VAR, RAYTRACE_DATA, PARAMS) \
    if (RAYTRACE_DATA.ray.x > 0.0) { \
        if (RAYTRACE_DATA.ray.y > 0.0) { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_px_py_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_px_py_nz PARAMS; \
            } \
        } else { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_px_ny_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_px_ny_nz PARAMS; \
            } \
        } \
    } else { \
        if (RAYTRACE_DATA.ray.y > 0.0) { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_nx_py_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_nx_py_nz PARAMS; \
            } \
        } else { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_nx_ny_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_nx_ny_nz PARAMS; \
            } \
        } \
    }

// Casts a given Ray, returns RayResult, also allows to offset given ray to skip some distance from its beginning
RayResult raytrace_direct(Ray ray_data, float ray_offset_dis) {
    ray_data.start /= 4.0;
    ray_data.max_distance /= 4.0;
    ray_offset_dis /= 4.0;

    RaytraceData raytrace_data;
    raytrace_data.ray = ray_data.ray = normalize(ray_data.ray);
    ray_data.start += ray_offset_dis * ray_data.ray;
    raytrace_data.start = ray_data.start;
    raytrace_data.voxel_distance = 0;

    ray_data.ray += (1.0 - abs(sign(ray_data.ray))) * 0.001;

    vec3 r2 = ray_data.ray * ray_data.ray;
    raytrace_data.rayS = vec3(
        sqrt(1.0 + r2.y / r2.x + r2.z / r2.x),
        sqrt(1.0 + r2.x / r2.y + r2.z / r2.y),
        sqrt(1.0 + r2.x / r2.z + r2.y / r2.z)
    );

    raytrace_data.pos = ivec3(floor(ray_data.start));
    raytrace_data.pos_step = ivec3(ray_data.ray.x > 0.0 ? 1 : -1, ray_data.ray.y > 0.0 ? 1 : -1, ray_data.ray.z > 0.0 ? 1 : -1);
    raytrace_data.distance = raytrace_data.distance_offset = ray_offset_dis;

    raytrace_data.rayL = vec3(
            (ray_data.ray.x > 0.0 ? (float(raytrace_data.pos.x + 1) - ray_data.start.x) : (ray_data.start.x - float(raytrace_data.pos.x))) * raytrace_data.rayS.x,
            (ray_data.ray.y > 0.0 ? (float(raytrace_data.pos.y + 1) - ray_data.start.y) : (ray_data.start.y - float(raytrace_data.pos.y))) * raytrace_data.rayS.y,
            (ray_data.ray.z > 0.0 ? (float(raytrace_data.pos.z + 1) - ray_data.start.z) : (ray_data.start.z - float(raytrace_data.pos.z))) * raytrace_data.rayS.z
        );

    RayResult result;

    float voxel_distance_factor = abs(ray_data.ray.x) + abs(ray_data.ray.y) + abs(ray_data.ray.z);
    RAYTRACE_FUNC_CALL(result, raytrace_data, (raytrace_data, ray_data.max_steps, int((ray_data.max_distance - ray_offset_dis) * voxel_distance_factor)));
    // result.end = (ray_data.start + ray_data.ray * (result.distance - ray_offset_dis)) * 4.0;
    result.distance *= 4.0;
    return result;
}

//

uint color_to_uint(vec4 color) {
    uvec4 c = uvec4(clamp(color, 0.0, 1.0) * 255.5);
    return (c.r << 24) | (c.g << 16) | (c.b << 8) | c.a;
}

vec4 uint_to_color(uint i) {
    // rgba
    return vec4(uvec4(i >> 24u, (i >> 16u) & 0xFFu, (i >> 8u) & 0xFFu, i & 0xFFu)) / 255.0;
}

vec4 normalize_packed_light_value(uvec2 packed_color) {
    vec4 color = vec4(uvec4(packed_color.x & 0xFFFFu, packed_color.x >> 16u, packed_color.y & 0xFFFFu, packed_color.y >> 16u)) / 255.0;
    color /= max(max(1.0, color.r), max(color.g, color.b));
    return color;
}

#define LOOP_OVER_SPHERE(X, Y, Z, R, CODE) \
    { \
        int _rad_sqr = R * R; \
        for (int X = -R; X <= R; X++) { \
            for (int Y = -R; Y <= R; Y++) { \
                for (int Z = -R; Z <= R; Z++) { \
                    int _local_dis_sqr = X * X + Y * Y + Z * Z; \
                    if (_local_dis_sqr > 0 && _local_dis_sqr <= _rad_sqr) CODE \
                } \
            } \
        } \
    }

// loop over sphere, excluding center, but for radius values 0 - 5
// pass constant values to macro instead of variable, and let the compiler optimize constant range for loop
#define LOOP_OVER_SPHERE_PRECOMPILE_OPT(X, Y, Z, R, CODE) \
    if (R > 0) { \
        if (R > 5) LOOP_OVER_SPHERE(X, Y, Z, R, CODE) \
        else if (R == 1) LOOP_OVER_SPHERE(X, Y, Z, 1, CODE) \
        else if (R == 2) LOOP_OVER_SPHERE(X, Y, Z, 2, CODE) \
        else if (R == 3) LOOP_OVER_SPHERE(X, Y, Z, 3, CODE) \
        else if (R == 4) LOOP_OVER_SPHERE(X, Y, Z, 4, CODE) \
        else if (R == 5) LOOP_OVER_SPHERE(X, Y, Z, 5, CODE) \
    }


//

#define VOLUME_THRESHOLD_REFLECT 0
#define VOLUME_THRESHOLD_BLOCK 0

int get_light_buffer_index(ivec3 ipos) {
    ivec3 chunk_pos = ipos >> 5;
    ivec3 voxel_pos = ipos & 31;
    ivec3 chunk_pos_off = chunk_pos - light_pass_offsets.region_offset;
    ivec3 chunk_region_size = light_pass_offsets.region_size;
    if (chunk_pos_off.x >= 0 && chunk_pos_off.y >= 0 && chunk_pos_off.z >= 0 && chunk_pos_off.x < chunk_region_size.x && chunk_pos_off.y < chunk_region_size.y && chunk_pos_off.z < chunk_region_size.z) {
        int buffer_offset = light_pass_offsets.offsets[chunk_pos_off.x + (chunk_pos_off.z + chunk_pos_off.y * chunk_region_size.z) * chunk_region_size.x];
        int light_offset = (buffer_offset + (voxel_pos.x + (voxel_pos.z + voxel_pos.y * 32) * 32)) * LIGHT_DATA_UNIT_COUNT;
        return light_offset;
    }
    return 0;
}

uvec2 clear_light_value(int buffer_index, int level) {
    int index = buffer_index + level * 2 + 1;
    uvec2 value = uvec2(light_pass_buffer.data[index], light_pass_buffer.data[index + 1]);
    light_pass_buffer.data[index] = 0u;
    light_pass_buffer.data[index + 1] = 0u;
    return value;
}

void add_packed_light_value(int buffer_index, int level, uvec2 packed_value) {
    int index = buffer_index + level * 2 + 1;
    atomicAdd(light_pass_buffer.data[index], packed_value.x);
    atomicAdd(light_pass_buffer.data[index + 1], packed_value.y);
}

void add_light_value(int buffer_index, int level, vec4 light_value) {
    uvec4 light_value_i = uvec4(clamp(vec4(light_value.rgb * light_value.a, light_value.a), 0.0, 1.0) * 255.0);
    add_packed_light_value(buffer_index, level, uvec2(light_value_i.r | (light_value_i.g << 16u), light_value_i.b | (light_value_i.a << 16u)));
}

int voxel_count_at(ivec3 pos) {
    ivec3 chunk_pos = pos >> 5;
    ivec3 chunk_pos_off = chunk_pos - render_region.offset;
    if (chunk_pos_off.x >= 0 && chunk_pos_off.y >= 0 && chunk_pos_off.z >= 0 && chunk_pos_off.x < render_region.count.x && chunk_pos_off.y < render_region.count.y && chunk_pos_off.z < render_region.count.z) {
        int chunk_buffer_offset = buffer_offsets.data[chunk_pos_off.x + (chunk_pos_off.z + chunk_pos_off.y * render_region.count.z) * render_region.count.x];
        ivec3 r2pos = (pos >> 2) & 7;
        ivec3 r1pos = pos & 3;
        int r2offset = chunk_buffer_offset + (r2pos.x | ((r2pos.z | (r2pos.y << 3)) << 3)) * 4161;
        int r1offset = r2offset + 1 + (r1pos.x | ((r1pos.z | (r1pos.y << 2)) << 2)) * 65;
        return int(render_buffer.data[r1offset]);
    }
}

int get_blocked_neighbours_count(ivec3 p) {
    int count = 0;
    for(int x = -1; x < 2; x++) {
        for(int y = -1; y < 2; y++) {
            for(int z = -1; z < 2; z++) {
                if (x == 0 && y == 0 && z == 0) continue;
                count += int(voxel_count_at(p + ivec3(x, y, z)) > VOLUME_THRESHOLD_BLOCK);
            }
        }
    }
    return count;
}


struct LightPropagateAgent {
    vec3 position;
    vec3 step;
};

void light_propagate(vec3 source, float offset_distance, vec4 light_value) {

}

void main() {
    // get current light job and voxel position
    LightJob job = light_pass_jobs.jobs[gl_GlobalInvocationID.y];
    int voxel_index = int(gl_GlobalInvocationID.x);
    int light_buffer_offset = (job.buffer_offset + voxel_index) * LIGHT_DATA_UNIT_COUNT;
    ivec3 voxel_pos = ivec3(voxel_index & 31, voxel_index >> 10, (voxel_index >> 5) & 31) + (job.chunk_position << 5);

    // make random adjustment for center position, so raytracing region step over will not end up in error state
    vec3 voxel_center = vec3(voxel_pos * 4) + vec3(2.01, 1.99, 2.00);

    // for level 0 do initial light pass, calculating direct light from sky and light sources
    if (job.level == 0) {
        // TODO: this must be done as separate pass, and not as the beginning of the initial light pass
        // on the initial pass finish light calculation:
        {
            // consume and normalize light value from last level, that contains all previous levels
            vec4 last_light_value = normalize_packed_light_value(clear_light_value(light_buffer_offset, LIGHT_LEVEL_COUNT - 1));
            light_pass_buffer.data[light_buffer_offset + LIGHT_DATA_UNIT_COUNT - 1] = color_to_uint(last_light_value);
        }

        // on the first pass store blocked neighbour count for future passes
        int blocked_neighbour_count = get_blocked_neighbours_count(voxel_pos);
        light_pass_buffer.data[light_buffer_offset] = uint(blocked_neighbour_count);

        // if voxel is non-empty or does not have neighbours (compute only for surfaces)
        if (voxel_count_at(voxel_pos) != 0 || blocked_neighbour_count == 0) {
            return;
        }

        // cast shadow ray
        RayResult shadow_ray_result = raytrace_direct(Ray(voxel_center, -ambient_data.direct_light_ray, 150.0, 100), 0.0);

        // calculate light value from skylight
        float dis_sum = 0.0;
        for (int i = 0; i < shadow_ray_result.intersection_count; i++) {
            dis_sum += shadow_ray_result.intersections[i].distance;
        }
        vec4 light_value = vec4(1.0, 0.0, 0.0, clamp(0.5 - dis_sum / 8.0, 0.0, 1.0));

        // add skylight to current voxel
        add_light_value(light_buffer_offset, 0, light_value);
    }
    // for levels [1; LIGHT_DATA_UNIT_COUNT - 1] emit light rays from previous level
    else {
        // consume previous level light value and add it to the current level
        uvec2 packed_light_value = clear_light_value(light_buffer_offset, (job.level + (LIGHT_LEVEL_COUNT - 1)) % LIGHT_LEVEL_COUNT);
        add_packed_light_value(light_buffer_offset, job.level, packed_light_value);

        // get normalized light value to emit
        /* vec4 light_value = normalize_packed_light_value(packed_light_value);
        if (light_value.a > 0.25) {
            LOOP_OVER_SPHERE(x, y, z, 3, {
                ivec3 target_pos = voxel_pos + ivec3(x, y, z);
                vec3 target_center = vec3(target_pos * 4) + vec3(2.01, 1.99, 2.00);

                vec3 ray = target_center - voxel_center;
                RayResult ray_result = raytrace_direct(Ray(voxel_center, ray, 25.0, 20), 0.0);
                float dis_sum = 0.0;
                for (int i = 0; i < ray_result.intersection_count; i++) {
                    dis_sum += ray_result.intersections[i].distance;
                }
                if (dis_sum < 2.0)
                add_light_value(get_light_buffer_index(target_pos), job.level, vec4(0.0, 0.0, 1.0, 0.1));
            });
        } */


        /*
        // consume light cache bit for this voxel and clear it
        uint light_cache_value = light_pass_buffer.data[light_buffer_offset];
        uint light_cache_bit_mask = (1u << uint(job.level - 1 + 5));
        uint light_cache_bit = light_cache_value & light_cache_bit_mask;
        light_pass_buffer.data[light_buffer_offset] = light_cache_value & (~light_cache_bit_mask);

        // all light cache bits must be consumed before going further, so no race conditions will occur
        barrier();

        vec4 reflected_light = vec4(0.0);

        light_pass_buffer.data[light_buffer_offset + job.level + 1] = light_cache_bit == 0u ? color_to_uint(vec4(0.0, 0.0, 1.0, 0.5)) : color_to_uint(vec4(1.0, 0.0, 1.0, 0.5));


        // reset buffer value
        light_pass_buffer.data[light_buffer_offset + job.level + 1] = 0u;
        barrier();

        // get light for job.level - 1
        vec4 light_value = uint_to_color(light_pass_buffer.data[light_buffer_offset + job.level]);

        // if it is bright enough to emit light
        // set nearby voxel value to 1
        if (light_value.a > 0.25) {
            for (int x = -3; x <= 3; x++) {
                for (int y = -3; x <= 3; x++) {
                    for (int z = -3; z <= 3; z++) {
                        if (x == 0 && y == 0 && z == 0) continue;
                        // no race condition will occur, as similar value is always set
                        light_pass_buffer.data[get_light_buffer_index(voxel_pos + ivec3(x, y, z)) + job.level + 1] = 1u;
                    }
                }
            }
        } */
    }
}