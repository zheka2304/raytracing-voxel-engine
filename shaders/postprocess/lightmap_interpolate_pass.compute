#version 310 es

#define WORK_GROUP_SIZE ${common.texture_work_group_size}

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE, local_size_z = 1) in;
layout(std430) buffer;

layout(rgba32f, binding = ${lightmap.last_frame}) uniform highp image2D lightmap_last_frame;
layout(rgba32f, binding = ${lightmap.current_frame}) uniform highp image2D lightmap_current_frame;
layout(rgba32f, binding = ${lightmap.blur_pass_texture}) uniform highp image2D blur_pass_texture;


#define BLEND_RATE_MIN float(${lighting.interpolate_blend_rate_min})
#define BLEND_RATE_FACTOR float(${lighting.interpolate_blend_rate_factor})

#define BLUR_SAMPLE_COUNT int(${lighting.interpolate_blur_sample_count})
#define BLUR_RATE_FACTOR float(${lighting.interpolate_blur_rate_factor})
#define BLUR_DEPTH_FACTOR float(${lighting.blur_depth_factor})
#define BLUR_VALUE_FACTOR float(${lighting.blur_value_factor})


#include "common.inc"
#include "buffer/spatial_buffer.inc"


float getLastFrameBlurredValue(ivec2 pixel, vec4 origin, float factor, int step) {
    float weight = 1.0;
    float value = origin.r;
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (x == 0 && y == 0) continue;
            vec4 pixel = imageLoad(lightmap_last_frame, pixel + ivec2(x, y) * step);
            float v = pixel.r;
            float w = factor;
            w -= abs(pixel.a - origin.a) / origin.a / BLUR_DEPTH_FACTOR * (1.0 - factor);
            w -= length(UNPACK_H2F(origin.g) - UNPACK_H2F(pixel.g));
            w += max(0.0, 1.0 - abs(v - origin.r) / BLUR_VALUE_FACTOR) * factor;
            w = clamp(w, 0.0, 1.0);
            weight += w;
            value += w * v;
        }
    }
    return value / weight;
}

float getLastFrameBlurredValueMultiSample(ivec2 pixel, float factor, int sample_count) {
    vec4 origin = imageLoad(lightmap_last_frame, pixel);
    if (factor < .1 || sample_count <= 0) {
        return origin.r;
    }
    float value = 0.0;
    for (int i = 0; i < sample_count; i++) {
        float s = getLastFrameBlurredValue(pixel, origin, factor, i * 2 + 1);
        value += s / float(sample_count);
        origin.r = s;
    }
    return value;
}

void main() {
    // get pixel and discard excess ones
    ivec2 image_size = imageSize(lightmap_current_frame);
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= image_size.x || pixel.y >= image_size.y) {
        return;
    }

    //
    SpatialBufferData spatial_buffer_data = ACCESS_SPATIAL_BUFFER(pixel);

    //
    float blur_factor = clamp(1.0 - spatial_buffer_data.value.w * BLUR_RATE_FACTOR, 0.0, 1.0);
    float last_value = getLastFrameBlurredValueMultiSample(spatial_buffer_data.pixel.xy, blur_factor, BLUR_SAMPLE_COUNT);
    vec4 current_value = imageLoad(lightmap_current_frame, pixel);

    float blend_value = clamp(1.0 - spatial_buffer_data.value.w * BLEND_RATE_FACTOR, BLEND_RATE_MIN, 1.0);
    current_value.r = mix(last_value, current_value.r, blend_value);
    imageStore(lightmap_current_frame, pixel, current_value);

    //
    imageStore(blur_pass_texture, pixel, vec4(
        PACK_H2F(vec2(current_value.r)),                               // light value
        current_value.a,                                               // distance from camera
        current_value.g,                                               // packed normal dot values
        PACK_H2F(vec2(current_value.r))                                // reserved for passes
    ));
}