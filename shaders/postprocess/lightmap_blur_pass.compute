#version 310 es

#define WORK_GROUP_SIZE ${common.texture_work_group_size}

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE, local_size_z = 1) in;
layout(std430) buffer;

layout(rgba32f, binding = ${lightmap.current_frame}) uniform highp image2D lightmap_texture;
layout(rgba32f, binding = ${lightmap.blur_pass_texture}) uniform highp image2D blur_pass_texture;


#include "common.inc"
#include "buffer/spatial_buffer.inc"


#ifdef D_PASS_PARITY_1
#define READ(X) (X).r
#define WRITE(X) (X).a
#define SHIFT(X) ivec2(X, 0)
#else
#define READ(X) (X).a
#define WRITE(X) (X).r
#define SHIFT(X) ivec2(0, X)
#endif

#define BLUR_DEPTH_FACTOR float(${lighting.blur_depth_factor})
#define BLUR_VALUE_FACTOR float(${lighting.blur_value_factor})
#define BLUR_SAMPLE_COUNT int(${lighting.denoise_blur_sample_count})
#define BLUR_SAMPLE_COUNT_ADD float(${lighting.denoise_blur_sample_count_add})


float get3x3Blur(ivec2 pos, vec4 origin, float origin_weight, int step) {
    float origin_val = UNPACK_H2F(READ(origin)).y;
    float sum = origin_val;
    float weight = origin_weight;

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (x == 0 && y == 0) continue;
            vec4 pixel = imageLoad(blur_pass_texture, pos + ivec2(x, y) * step);
            float v = UNPACK_H2F(READ(pixel)).y;
            float w = 1.0;
            w -= abs(pixel.g - origin.g) / origin.g / BLUR_DEPTH_FACTOR;
            w -= length(UNPACK_H2F(origin.b) - UNPACK_H2F(pixel.b));
            w += max(0.0, 1.0 - abs(v - origin_val) / BLUR_VALUE_FACTOR);
            w = clamp(w, 0.0, 1.0);
            sum += v * w;
            weight += w;
        }
    }
    return sum / weight;
}

float getMultiSample3x3Blur(ivec2 pos, int sample_count) {
    float value = 0.0;
    vec4 origin = imageLoad(blur_pass_texture, pos);
    if (sample_count <= 0) {
        return READ(origin);
    }
    for (int i = 0; i < sample_count; i++) {
        value += get3x3Blur(pos, origin, 1.0, i * 2 + 1) / float(sample_count);
    }
    return value;
}


void main() {
    // get pixel and discard excess ones
    ivec2 image_size = imageSize(lightmap_texture);
    ivec2 pixel_pos = ivec2(gl_GlobalInvocationID.xy);
    if (pixel_pos.x >= image_size.x || pixel_pos.y >= image_size.y) {
        return;
    }
    image_size--;

#ifdef D_BLUR_PASS
    vec4 pixel = imageLoad(blur_pass_texture, pixel_pos);
    vec2 pixel_value = UNPACK_H2F(READ(pixel));
    float value = pixel_value.x;
    float weight = 1.0;

    int sample_size = 15;
    for (int i = -sample_size; i <= sample_size; i++) {
        if (i == 0) continue;
        ivec2 pos1 = pixel_pos + SHIFT(i);
        vec4 pixel1 = imageLoad(blur_pass_texture, pos1);
        float v = UNPACK_H2F(READ(pixel1)).x;
        float w = 1.0;// - abs(READ(pixel) - v) * 0.5;
        value += v * w;
        weight += w;
    }

    pixel_value.x = value / weight;
    WRITE(pixel) = PACK_H2F(pixel_value);
    imageStore(blur_pass_texture, pixel_pos, pixel);
#endif

#ifdef D_3X3_FILTER_PASS
    vec4 pixel = imageLoad(blur_pass_texture, pixel_pos);
    vec2 pixel_value = UNPACK_H2F(READ(pixel));
    float spatial_stability = ACCESS_SPATIAL_BUFFER(pixel_pos).value.w;
    pixel_value.y = getMultiSample3x3Blur(pixel_pos, BLUR_SAMPLE_COUNT + int((1.0 - spatial_stability) * BLUR_SAMPLE_COUNT_ADD));
    WRITE(pixel) = PACK_H2F(pixel_value);
    imageStore(blur_pass_texture, pixel_pos, pixel);
#endif

}