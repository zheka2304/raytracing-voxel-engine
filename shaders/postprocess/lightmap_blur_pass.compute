#version 310 es

#define WORK_GROUP_SIZE ${common.texture_work_group_size}

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE, local_size_z = 1) in;
layout(std430) buffer;

layout(rgba32f, binding = ${lightmap.current_frame}) uniform highp image2D lightmap_texture;
layout(rgba32f, binding = ${lightmap.blur_pass_texture}) uniform highp image2D blur_pass_texture;


#include "common.inc"
#include "buffer/spatial_buffer.inc"


#ifdef D_PASS_PARITY_1
#define READ(X) (X).r
#define WRITE(X) (X).a
#define SHIFT(X) ivec2(X, 0)
#else
#define READ(X) (X).a
#define WRITE(X) (X).r
#define SHIFT(X) ivec2(0, X)
#endif


float get3x3Blur(ivec2 pos, vec4 origin, float origin_weight, int step) {
    float origin_val = UNPACK_H2F(READ(origin)).y;
    float sum = origin_val * origin_weight;
    float weight = origin_weight;

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (x == 0 && y == 0) continue;
            vec4 pixel = imageLoad(blur_pass_texture, pos + ivec2(x, y) * step);
            float v = UNPACK_H2F(READ(pixel)).y;
            float w = 1.0;
            w -= abs(pixel.g - origin.g) / origin.g / float(${lighting.blur_depth_factor});
            w -= length(UNPACK_H2F(origin.b) - UNPACK_H2F(pixel.b));
            w += max(0.0, 1.0 - abs(v - origin_val) / float(${lighting.blur_value_factor}));
            w = clamp(w, 0.0, 1.0);
            sum += v * w;
            weight += w;
        }
    }
    return sum / weight;
}

float getMultiSample3x3Blur(ivec2 pos, float spatial_stability) {
    vec4 origin = imageLoad(blur_pass_texture, pos);
    float origin_val = UNPACK_H2F(READ(origin)).y;
    int sample_count = int(${lighting.denoise_blur_sample_count}) + int((1.0 - spatial_stability) * float(${lighting.denoise_blur_sample_count_add}));
    if (sample_count <= 0) {
        return origin_val;
    }

    float eps = float(${lightmap.denoise_blur_optimization_epsilon});
    if ((origin_val < eps || origin_val > 1.0 - eps) && spatial_stability > 0.1) {
        return origin_val;
    }

    float value = 0.0;
    for (int i = 0; i < sample_count; i++) {
        value += get3x3Blur(pos, origin, 1.0, i * 2 + 1) / float(sample_count);
    }
    return value;
}


void main() {
    // get pixel and discard excess ones
    ivec2 image_size = imageSize(lightmap_texture);
    ivec2 pixel_pos = ivec2(gl_GlobalInvocationID.xy);
    if (pixel_pos.x >= image_size.x || pixel_pos.y >= image_size.y) {
        return;
    }
    image_size--;

#ifdef D_BLUR_PASS
    vec4 pixel = imageLoad(blur_pass_texture, pixel_pos);
    vec2 pixel_value = UNPACK_H2F(READ(pixel));
    float value = pixel_value.x;
    float weight = 1.0;

    image_size--;
    int sample_size = int(${lighting.linear_blur_sample_count});
    for (int i = -sample_size; i <= sample_size; i++) {
        if (i == 0) continue;
        ivec2 pos1 = clamp(pixel_pos + SHIFT(i) * int(${lighting.linear_blur_sample_step}), ivec2(0.0), image_size);
        vec4 pixel1 = imageLoad(blur_pass_texture, pos1);
        float v = UNPACK_H2F(READ(pixel1)).x;
        float w = max(0.0, 1.0 - abs(pixel1.g - pixel.g) / pixel.g / float(${lighting.linear_blur_distance_factor}));
        value += v * w;
        weight += w;
    }

    pixel_value.x = value / weight;
    WRITE(pixel) = PACK_H2F(pixel_value);
    imageStore(blur_pass_texture, pixel_pos, pixel);
#endif

#ifdef D_3X3_FILTER_PASS
    vec4 pixel = imageLoad(blur_pass_texture, pixel_pos);
    vec2 pixel_value = UNPACK_H2F(READ(pixel));
    float spatial_stability = ACCESS_SPATIAL_BUFFER(pixel_pos).value.w;
    pixel_value.y = getMultiSample3x3Blur(pixel_pos, spatial_stability);
//    pixel_value.y = mix(pixel_value.x, pixel_value.y, spatial_stability);
    WRITE(pixel) = PACK_H2F(pixel_value);

    // -- DEBUG START --
//    #ifdef D_PASS_PARITY_2
//        pixel.b = 1.0 - ACCESS_SPATIAL_BUFFER(pixel_pos).value.w;
//    #endif
    // -- DEBUG END --

    imageStore(blur_pass_texture, pixel_pos, pixel);
#endif

}