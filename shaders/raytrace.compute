#version 310 es
layout(local_size_x = 24, local_size_y = 24, local_size_z = 1) in;
layout(std430) buffer;

// defines

#ifdef PRE_RAYTRACE
    #define STAGE_PRE_RAYTRACE(A) A
    #define STAGE_MAIN_PASS(A)
#else
    #define STAGE_PRE_RAYTRACE(A)
    #define STAGE_MAIN_PASS(A) A
#endif

//

layout(binding = 3) readonly buffer RenderBuffer {
    uint data[];
} render_buffer;

layout(binding = 4) readonly buffer BufferOffsets {
    int data[];
} buffer_offsets;

layout(binding = 5) readonly buffer RenderRegion {
    ivec3 offset;
    ivec3 count;
} render_region;

layout(binding = 6) readonly buffer AmbientData {
    vec4 direct_light_color;
    vec3 direct_light_ray;
    vec4 ambient_light_color;
} ambient_data;

layout(binding = 7) readonly buffer Camera {
    float time;
    vec4 viewport;
    vec3 camera_position;
    vec3 camera_ray;
    vec2 camera_near_and_far;
} camera;

layout(binding = 8) STAGE_PRE_RAYTRACE(writeonly) STAGE_MAIN_PASS(readonly) buffer PreRaytraceBuffer {
    float data[];
} pre_raytrace_buffer;

layout(binding = 9) readonly buffer PreRaytraceLod {
    int stride_bit;    // resolution downgrade (1 << stride_bit, 1 means x2, 2 means x4, 3 - x8, ...)
    ivec2 buffer_size; // pre-raytrace buffer dimensions
    float dis_1; // max distance at which tier 1 regions are used
    float dis_2; // max distance at which tier 2 regions are used
    // after that distances full chunks are used
} pre_raytrace_lod;


layout(rgba32f, binding = 0) writeonly uniform highp image2D COLOR_OUTPUT;
layout(rgba32f, binding = 1) writeonly uniform highp image2D LIGHT_OUTPUT;
layout(rgba32f, binding = 2) writeonly uniform highp image2D DEPTH_OUTPUT;

// --- raytracing logic ---

#define PI 3.1415926

struct RaytraceData {
    vec3 start; // starting position
    vec3 ray; // ray is normalized
    vec3 rayS; // S value for each coordinate
    vec3 rayL;
    float distance; // total distance
    float distance_offset; // offset distance
    int voxel_distance; // counter for voxel steps to check for region end
    ivec3 pos; // cell position
    ivec3 pos_step;

    STAGE_PRE_RAYTRACE(
        int lod_1;
        int lod_2;
    )
};

struct RegTraverseData {
    vec3 add_f;
    ivec3 add_i;
    int region_end;
};


#define BINARY_CHOICE_AB_A(A, B) A
#define BINARY_CHOICE_AB_B(A, B) B

#define RAYTRACE_DDA_STEP(RAYTRACE_DATA, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
    { \
        bvec3 _mask = lessThanEqual(RAYTRACE_DATA.rayL, min(RAYTRACE_DATA.rayL.yzx, RAYTRACE_DATA.rayL.zxy)); \
        RAYTRACE_DATA.rayL += vec3(_mask) * RAYTRACE_DATA.rayS; \
        RAYTRACE_DATA.pos += ivec3(_mask) * RAYTRACE_DATA.pos_step; \
        RAYTRACE_DATA.voxel_distance++; \
    }


#define PREPARE_TO_TRAVERSE_REGION(RAYTRACE_DATA, DATA_VAR, REGION_SIZE, REGION_SIZE_BIT_MASK, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
    { \
        ivec3 COUNT_ = ivec3( \
            IS_RAY_X_POSITIVE(REGION_SIZE - (RAYTRACE_DATA.pos.x & REGION_SIZE_BIT_MASK), (RAYTRACE_DATA.pos.x & REGION_SIZE_BIT_MASK) + 1),  \
            IS_RAY_Y_POSITIVE(REGION_SIZE - (RAYTRACE_DATA.pos.y & REGION_SIZE_BIT_MASK), (RAYTRACE_DATA.pos.y & REGION_SIZE_BIT_MASK) + 1),  \
            IS_RAY_Z_POSITIVE(REGION_SIZE - (RAYTRACE_DATA.pos.z & REGION_SIZE_BIT_MASK), (RAYTRACE_DATA.pos.z & REGION_SIZE_BIT_MASK) + 1)  \
        ); \
        \
        vec3 _rayL_ = RAYTRACE_DATA.rayL + RAYTRACE_DATA.rayS * vec3(COUNT_ - 1); \
        \
        vec2 _add_yz = (_rayL_.x - RAYTRACE_DATA.rayL.yz) / RAYTRACE_DATA.rayS.yz; \
        vec2 _add_xz = (_rayL_.y - RAYTRACE_DATA.rayL.xz) / RAYTRACE_DATA.rayS.xz; \
        vec2 _add_xy = (_rayL_.z - RAYTRACE_DATA.rayL.xy) / RAYTRACE_DATA.rayS.xy; \
        \
        ivec3 _add_i_1 = max(ivec3(0), ivec3(ceil(vec3(_add_yz.x, _add_xz.x, _add_xy.x)))); \
        ivec3 _add_i_2 = max(ivec3(0), ivec3(ceil(vec3(_add_yz.y, _add_xz.y, _add_xy.y)))); \
        \
        ivec3 _dis_ = _add_i_1 + _add_i_2 + COUNT_;  \
        \
        if (_dis_.x < _dis_.y) {  \
            if (_dis_.z < _dis_.x) { \
                DATA_VAR.add_i = ivec3(_add_i_1.z, _add_i_2.z, COUNT_.z); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.z; \
            } else { \
                DATA_VAR.add_i = ivec3(COUNT_.x, _add_i_1.x, _add_i_2.x); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.x; \
            } \
        } else { \
            if (_dis_.z < _dis_.y) { \
                DATA_VAR.add_i = ivec3(_add_i_1.z, _add_i_2.z, COUNT_.z); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.z; \
            } else { \
                DATA_VAR.add_i = ivec3(_add_i_1.y, COUNT_.y, _add_i_2.y); \
                DATA_VAR.region_end = RAYTRACE_DATA.voxel_distance + _dis_.y; \
            } \
        } \
    }

#define DO_TRAVERSE_REGION(RAYTRACE_DATA, DATA_VAR, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
    { \
        RAYTRACE_DATA.rayL += vec3(DATA_VAR.add_i) * RAYTRACE_DATA.rayS; \
        RAYTRACE_DATA.pos += DATA_VAR.add_i * RAYTRACE_DATA.pos_step; \
        RAYTRACE_DATA.voxel_distance = DATA_VAR.region_end; \
    }

#define NOT_TRAVERSE_REGION_END(RAYTRACE_DATA, DATA_VAR) RAYTRACE_DATA.voxel_distance < DATA_VAR.region_end

#define EXTRACT_RAYTRACE_DISTANCE_AND_SIDE(RAYTRACE_DATA, RESULT_VAR, SIDE_VAR) \
    { \
        vec3 _lastRayL = RAYTRACE_DATA.rayL - RAYTRACE_DATA.rayS; \
        RESULT_VAR = max(_lastRayL.x, max(_lastRayL.y, _lastRayL.z)); \
        if (_lastRayL.x > _lastRayL.y) { \
            if (_lastRayL.x > _lastRayL.z) { \
                RESULT_VAR = RAYTRACE_DATA.distance_offset + _lastRayL.x; \
                SIDE_VAR = vec3(-RAYTRACE_DATA.pos_step.x, 0, 0); \
            } else { \
                RESULT_VAR = RAYTRACE_DATA.distance_offset + _lastRayL.z; \
                SIDE_VAR = vec3(0, 0, -RAYTRACE_DATA.pos_step.z); \
            } \
        } else { \
            if (_lastRayL.y > _lastRayL.z) { \
                RESULT_VAR = RAYTRACE_DATA.distance_offset + _lastRayL.y; \
                SIDE_VAR = vec3(0, -RAYTRACE_DATA.pos_step.y, 0); \
            } else { \
                RESULT_VAR = RAYTRACE_DATA.distance_offset + _lastRayL.z; \
                SIDE_VAR = vec3(0, 0, -RAYTRACE_DATA.pos_step.z); \
            } \
        } \
    }


#define MAIN_RAYTRACE_FUNC_PRE_RAYTRACE_EXIT \
    steps_made = i; \
    EXTRACT_RAYTRACE_DISTANCE_AND_SIDE(raytrace_data, distance_to_voxel, voxel_side); \
    return 1u; \


#define MAIN_RAYTRACE_FUNC(FUNC_NAME, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE) \
uint FUNC_NAME(in RaytraceData raytrace_data, int max_steps, int max_distance, out int steps_made, out float distance_to_voxel, out vec3 voxel_side) { \
    RegTraverseData tier1_region; \
    RegTraverseData tier2_region; \
    RegTraverseData chunk_region; \
    \
    int i = 0; \
    while(i < max_steps) { \
        ivec3 chunk_pos = raytrace_data.pos >> 7; \
        ivec3 chunk_pos_off = chunk_pos - render_region.offset; \
        \
        if (raytrace_data.voxel_distance > max_distance) { \
            steps_made = i; \
            distance_to_voxel = float(max_distance); \
            return 0u; \
        } \
        \
        PREPARE_TO_TRAVERSE_REGION(raytrace_data, chunk_region, 128, 127, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); \
        /* if in bound of chunk, raytrace it */ \
        if (chunk_pos_off.x >= 0 && chunk_pos_off.y >= 0 && chunk_pos_off.z >= 0 && chunk_pos_off.x < render_region.count.x && chunk_pos_off.y < render_region.count.y && chunk_pos_off.z < render_region.count.z) { \
            /* on stage pre-raytrace stage when over LOD 2 distance, return as chunk was hit */ \
            STAGE_PRE_RAYTRACE( \
                if (raytrace_data.voxel_distance > raytrace_data.lod_2) { \
                    MAIN_RAYTRACE_FUNC_PRE_RAYTRACE_EXIT \
                } \
            ) \
            /* get buffer offset from chunk */ \
            int chunk_buffer_offset = buffer_offsets.data[chunk_pos_off.x + (chunk_pos_off.z + chunk_pos_off.y * render_region.count.z) * render_region.count.x]; \
            /* iterate while inside this chunk */ \
            while (i < max_steps) { \
                if (NOT_TRAVERSE_REGION_END(raytrace_data, chunk_region)) { \
                    /* raytrace over tier 2 region */ \
                    ivec3 r2pos = (raytrace_data.pos >> 4) & 7; \
                    int r2offset = chunk_buffer_offset + (r2pos.x | ((r2pos.z | (r2pos.y << 3)) << 3)) * 4161; \
                    \
                    if (raytrace_data.voxel_distance > max_distance) { \
                        steps_made = i; \
                        distance_to_voxel = float(max_distance); \
                        return 0u; \
                    } \
                    \
                    PREPARE_TO_TRAVERSE_REGION(raytrace_data, tier2_region, 16, 15, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); \
                    if (render_buffer.data[r2offset] != 0u) { \
                        /* on pre-raytrace stage when over LOD 1 distance, return as tier 2 region was hit */ \
                        STAGE_PRE_RAYTRACE( \
                            if (raytrace_data.voxel_distance > raytrace_data.lod_1) { \
                                MAIN_RAYTRACE_FUNC_PRE_RAYTRACE_EXIT \
                            } \
                        ) \
                        /* region is non-empty, raytrace over tier 1 */ \
                        while (NOT_TRAVERSE_REGION_END(raytrace_data, tier2_region)) { \
                            /* raytrace over tier 1 region */ \
                            ivec3 r1pos = (raytrace_data.pos >> 2) & 3; \
                            int r1offset = r2offset + 1 + (r1pos.x | ((r1pos.z | (r1pos.y << 2)) << 2)) * 65; \
                            \
                            PREPARE_TO_TRAVERSE_REGION(raytrace_data, tier1_region, 4, 3, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); \
                            if (render_buffer.data[r1offset] != 0u) { \
                                /* on pre-raytrace stage exit on tier 1 region hit */ \
                                STAGE_PRE_RAYTRACE( \
                                    MAIN_RAYTRACE_FUNC_PRE_RAYTRACE_EXIT \
                                ) \
                                /* region is non-empty, raytrace over voxels */ \
                                while (NOT_TRAVERSE_REGION_END(raytrace_data, tier1_region)) { \
                                    ivec3 voxel_pos = raytrace_data.pos & 3; \
                                    int voxel_index = r1offset + 1 + (voxel_pos.x | ((voxel_pos.z | (voxel_pos.y << 2)) << 2)); \
                                    uint voxel = render_buffer.data[voxel_index]; \
                                    if (voxel != 0u) { \
                                        /* voxel found, end iteration */ \
                                        steps_made = i; \
                                        EXTRACT_RAYTRACE_DISTANCE_AND_SIDE(raytrace_data, distance_to_voxel, voxel_side); \
                                        return voxel; \
                                    } \
                                    /* make voxel step */ \
                                    RAYTRACE_DDA_STEP(raytrace_data, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
                                } \
                            } else { \
                                /* region is empty, skip (make tier 1 step) */ \
                                DO_TRAVERSE_REGION(raytrace_data, tier1_region, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
                            } \
                        } \
                    } else { \
                        /* region is empty, skip (make tier 2 step) */ \
                        DO_TRAVERSE_REGION(raytrace_data, tier2_region, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
                    } \
                } else { \
                    i++; \
                    break; \
                } \
            } \
        } else { \
            DO_TRAVERSE_REGION(raytrace_data, chunk_region, IS_RAY_X_POSITIVE, IS_RAY_Y_POSITIVE, IS_RAY_Z_POSITIVE); i++; \
        } \
    } \
    EXTRACT_RAYTRACE_DISTANCE_AND_SIDE(raytrace_data, distance_to_voxel, voxel_side); \
    steps_made = max_steps; \
    return 0u; \
}

MAIN_RAYTRACE_FUNC(raytrace_next_px_py_pz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_py_pz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_px_ny_pz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_ny_pz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A)
MAIN_RAYTRACE_FUNC(raytrace_next_px_py_nz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_py_nz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B)
MAIN_RAYTRACE_FUNC(raytrace_next_px_ny_nz, BINARY_CHOICE_AB_A, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B)
MAIN_RAYTRACE_FUNC(raytrace_next_nx_ny_nz, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B, BINARY_CHOICE_AB_B)


#define RAYTRACE_FUNC_CALL(RESULT_VAR, RAYTRACE_DATA, PARAMS) \
    if (RAYTRACE_DATA.ray.x > 0.0) { \
        if (RAYTRACE_DATA.ray.y > 0.0) { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_px_py_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_px_py_nz PARAMS; \
            } \
        } else { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_px_ny_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_px_ny_nz PARAMS; \
            } \
        } \
    } else { \
        if (RAYTRACE_DATA.ray.y > 0.0) { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_nx_py_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_nx_py_nz PARAMS; \
            } \
        } else { \
            if (RAYTRACE_DATA.ray.z > 0.0) { \
                RESULT_VAR = raytrace_next_nx_ny_pz PARAMS; \
            } else { \
                RESULT_VAR = raytrace_next_nx_ny_nz PARAMS; \
            } \
        } \
    }


uint raytrace_direct(vec3 start, vec3 ray, float ray_offset_dis, int max_steps, float max_distance, out int steps_made, out float distance_to_voxel, out vec3 voxel_side) {
    RaytraceData raytrace_data;
    raytrace_data.ray = ray = normalize(ray);
    start += ray_offset_dis * normalize(ray);
    raytrace_data.start = start;

    vec3 r2 = ray * ray;
    raytrace_data.rayS = vec3(
        sqrt(1.0 + r2.y / r2.x + r2.z / r2.x),
        sqrt(1.0 + r2.x / r2.y + r2.z / r2.y),
        sqrt(1.0 + r2.x / r2.z + r2.y / r2.z)
    );

    raytrace_data.pos = ivec3(floor(start));
    raytrace_data.pos_step = ivec3(ray.x > 0.0 ? 1 : -1, ray.y > 0.0 ? 1 : -1, ray.z > 0.0 ? 1 : -1);
    raytrace_data.distance = raytrace_data.distance_offset = ray_offset_dis;

    raytrace_data.rayL = vec3(
            (ray.x > 0.0 ? (float(raytrace_data.pos.x + 1) - start.x) : (start.x - float(raytrace_data.pos.x))) * raytrace_data.rayS.x,
            (ray.y > 0.0 ? (float(raytrace_data.pos.y + 1) - start.y) : (start.y - float(raytrace_data.pos.y))) * raytrace_data.rayS.y,
            (ray.z > 0.0 ? (float(raytrace_data.pos.z + 1) - start.z) : (start.z - float(raytrace_data.pos.z))) * raytrace_data.rayS.z
        );

    uint result;

    float voxel_distance_factor = abs(ray.x) + abs(ray.y) + abs(ray.z);
    STAGE_PRE_RAYTRACE(
        raytrace_data.lod_1 = int(pre_raytrace_lod.dis_1 * voxel_distance_factor);
        raytrace_data.lod_2 = int(pre_raytrace_lod.dis_2 * voxel_distance_factor);
    )

    RAYTRACE_FUNC_CALL(result, raytrace_data, (raytrace_data, max_steps, int((max_distance - ray_offset_dis) * voxel_distance_factor), steps_made, distance_to_voxel, voxel_side));
    return result;
}

float get_region_end_distance(vec3 pos, vec3 ray, float region_size) {
    vec3 region_offset = floor(pos / region_size) * region_size;

    vec3 r2 = ray * ray;
    vec3 rayS = vec3(
        sqrt(1.0 + r2.y / r2.x + r2.z / r2.x),
        sqrt(1.0 + r2.x / r2.y + r2.z / r2.y),
        sqrt(1.0 + r2.x / r2.z + r2.y / r2.z)
    );

    return min(
        (ray.x > 0.0 ? (region_offset.x + region_size - pos.x) : (pos.x - region_offset.x)) * rayS.x,
        min(
            (ray.y > 0.0 ? (region_offset.y + region_size - pos.y) : (pos.y - region_offset.y)) * rayS.y,
            (ray.z > 0.0 ? (region_offset.z + region_size - pos.z) : (pos.z - region_offset.z)) * rayS.z
        )
    );
}


// ---- raytrace caller ---

void raytrace(
        int buffer_index, // pre raytrace buffer index
        vec3 start,
        vec3 ray,
        int max_steps,
        float max_distance,
        float max_distance_light,
        out vec3 out_color,
        out float out_depth,
        out vec3 out_light
    ) {
    ray = normalize(ray);

    // on the main pass extract main ray offset from pre-raytrace buffer
    STAGE_MAIN_PASS(
        float main_ray_offset = pre_raytrace_buffer.data[buffer_index];
    )

    int steps_made;
    float distance_to_voxel;
    vec3 voxel_normal;

    // run raytracing for main ray, on pre-raytrace stage with no offset,
    // and on main stage with offset from pre-raytrace stage
    uint result = raytrace_direct(
        start, ray,
        STAGE_PRE_RAYTRACE(0.0) STAGE_MAIN_PASS(main_ray_offset),
        max_steps, max_distance,
        steps_made, distance_to_voxel, voxel_normal);

    // on pre-raytrace stage use distance to collision to find ray offset and store it in pre-raytrace buffer
    STAGE_PRE_RAYTRACE(
        // subtract possible error value from offset
        // this value is pre-calculated for each level of detail (tier 1, tier 2 and chunk)
        float out_main_ray_offset;
        if (distance_to_voxel > pre_raytrace_lod.dis_2) {
            out_main_ray_offset = distance_to_voxel - 40.0; // LOD: chunk
        } else if (distance_to_voxel > pre_raytrace_lod.dis_1) {
            out_main_ray_offset = distance_to_voxel - 5.0;  // LOD: tier 2
        } else {
            out_main_ray_offset = distance_to_voxel - 2.0;  // LOD: tier 1
        }
        // store value in pre-raytrace buffer
        pre_raytrace_buffer.data[buffer_index] = pre_raytrace_buffer.data[buffer_index + 1] = out_main_ray_offset;
    )

    // on main pass, check, if ray missed approximate offset found on pre-render stage,
    // and travelled much further, this will be used in shadow calculation:
    // if ray has missed, we discard pre-rendered shadow data, as it is invalid
    STAGE_MAIN_PASS(
        // 15.0 is hardcoded threshold, maybe in the future it should be passes it as a uniform or calculated
        bool initial_ray_missed = distance_to_voxel > main_ray_offset + 15.0;
    )

    // on the main stage if result is 0, return the sky color
    STAGE_MAIN_PASS(
        if (result == 0u) {
            out_color = vec3(0.5, 0.7, 1.0);
            out_light = vec3(1.0);
            return;
        }
    )

    // otherwise get color of voxel
    STAGE_MAIN_PASS(
        out_color = vec3(1.0);
    )

    // if we need to calculate direct light shadows
    if (ambient_data.direct_light_color.a > 0.01) {
        // get light direction
        vec3 light_dir = normalize(ambient_data.direct_light_ray);

        // on pre-raytrace stage raytrace light from other side to find maximum distance
        // from this point to raytrace light on main stage
        STAGE_PRE_RAYTRACE(
            // we will additionally offset ray start for hardcoded value (5.0)
            // i assume this is working, because 5.0 is average main stage ray travel length for LOD1
            // so consider checking LOD in the future  
            vec3 shadow_ray_start = start + ray * (distance_to_voxel + 5.0);
            shadow_ray_start -= light_dir * (max_distance_light + 0.01);
            vec3 shadow_ray = light_dir;
        )

        // on main pass we will use maximum distance, found on pre-raytrace stage
        // additionally we discard pre-raytrace data, if initial ray had missed
        STAGE_MAIN_PASS(
            vec3 shadow_ray_start = start + ray * distance_to_voxel + voxel_normal * 0.1;
            vec3 shadow_ray = -light_dir;
            float shadow_ray_length = initial_ray_missed ? max_distance_light : max_distance_light - pre_raytrace_buffer.data[buffer_index + 2];

            // this is used to highlight regions, where pre-raytrace data was discarded
            /* if (initial_ray_missed) {
                out_color = vec3(1.0, 0.0, 0.0);
            } */
        )

        // run raytracing for shadows with precalculated parameters
        int s_steps_made;
        float s_distance_to_voxel;
        vec3 s_voxel_normal;
        uint shadow_raytrace_result = raytrace_direct(
            shadow_ray_start, shadow_ray,
            0.0,
            max_steps - steps_made,
            STAGE_PRE_RAYTRACE(max_distance_light) STAGE_MAIN_PASS(shadow_ray_length),
            s_steps_made, s_distance_to_voxel, s_voxel_normal);

        // this is debug code, it is used to show shadow regions calculated with pre-raytracing distances, that do
        // not match with shadows, calculated with full distance raytracing
        /*
        STAGE_MAIN_PASS(
            uint shadow_raytrace_result_debug = raytrace_direct(
                        shadow_ray_start, shadow_ray,
                        0.0,
                        max_steps - steps_made,
                        max_distance_light,
                        s_steps_made, s_distance_to_voxel, s_voxel_normal);
            out_color = shadow_raytrace_result_debug == shadow_raytrace_result ? vec3(1.0) : vec3(1.0, 0.0, 0.0);
        ) */

        // on pre-raytrace stage store value found in buffer
        // and subtract possible error
        STAGE_PRE_RAYTRACE(
            pre_raytrace_buffer.data[buffer_index + 2] = pre_raytrace_buffer.data[buffer_index + 3] = max(0.0, s_distance_to_voxel - 5.0);
        )

        // on main pass calculate normals, and light color
        STAGE_MAIN_PASS(
            uint packed_normal = result >> 8;
            float n_yaw = float(packed_normal >> 5u) / 63.0 * PI * 2.0 - PI;
            float n_pitch = float(packed_normal & 31u) / 31.0 * PI - PI / 2.0;
            float n_pitch_cos = cos(n_pitch);
            vec3 normal = vec3(cos(n_yaw) * n_pitch_cos, sin(n_pitch), sin(n_yaw) * n_pitch_cos);
            // vec3 normal = normalize(vec3(float(int(packed_normal >> 12) - 32), float(int((packed_normal >> 6) & 63u) - 32), float(int(packed_normal & 63u) - 32)));

            normal = mix(normal, voxel_normal, 0.5);

            float direct_light_intensity = shadow_raytrace_result == 0u ? 1.0 : ambient_data.ambient_light_color.a;
            direct_light_intensity *= ambient_data.direct_light_color.a * (dot(-light_dir, normal) * 0.5 + 0.5);
            out_light = mix(ambient_data.ambient_light_color.rgb, ambient_data.direct_light_color.rgb, direct_light_intensity);

            // out_light = vec3(s_steps_made) / 50.0;
            // out_light = vec3(shadow_ray_length) / 50.0;
        )
        // out_color = normal * 0.5 + 0.5;// vec3(n_yaw / (2 * PI) + 0.5, n_pitch / (2 * PI) + 0.5, 0.0);
        // return;
    } else {
        // if no direct light exist, just use ambient light
        STAGE_MAIN_PASS(
            out_light = ambient_data.ambient_light_color.rgb;
        )
    }
}

// ----- entry point ------

void main() {
    int stride_bit = pre_raytrace_lod.stride_bit;
    ivec2 image_size = imageSize(COLOR_OUTPUT);

    STAGE_PRE_RAYTRACE(
        ivec2 pre_raytrace_pixel = ivec2(gl_GlobalInvocationID.xy);
        // get pixel and discard excess ones
        if (pre_raytrace_pixel.x >= pre_raytrace_lod.buffer_size.x || pre_raytrace_pixel.y >= pre_raytrace_lod.buffer_size.y) {
            return;
        }
        ivec2 pixel = pre_raytrace_pixel << stride_bit;
    )

    STAGE_MAIN_PASS(
        ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
        // get pixel and discard excess ones
        if (pixel.x >= image_size.x || pixel.y >= image_size.y) {
            return;
        }
    )


    vec3 start = camera.camera_position;
    vec3 forward = normalize(camera.camera_ray);
    vec3 right = vec3(forward.z, 0.0, -forward.x);
    vec3 up = cross(forward, right);
    vec2 xy = (vec2(pixel) / vec2(image_size) - 0.5) * camera.viewport.zw + camera.viewport.xy;
    start += (xy.x * normalize(right) + xy.y * normalize(up));
    float max_depth = camera.camera_near_and_far.y - camera.camera_near_and_far.x;

    vec3 out_color;
    float out_depth;
    vec3 out_light;

    int buffer_index = (pre_raytrace_lod.buffer_size.x * (pixel.y >> stride_bit) + (pixel.x >> stride_bit)) << 2;
    raytrace(
        buffer_index,                                   // pre render buffer index
        start + forward * camera.camera_near_and_far.x, // start
        forward,                                        // ray
        200,                                            // max steps
        max_depth,                                      // max distance
        100.0,                                          // max light distance
        out_color,                                      // result color
        out_depth,                                      // result depth
        out_light                                       // result light color
    );

    // write colors
    STAGE_MAIN_PASS(
        imageStore(COLOR_OUTPUT, pixel, vec4(out_color, 1.0));
        imageStore(LIGHT_OUTPUT, pixel, vec4(out_light, 1.0));
        imageStore(DEPTH_OUTPUT, pixel, vec4(vec3(out_depth / max_depth), 1.0));
    )
}