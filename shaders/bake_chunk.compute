#version 310 es
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(std430) buffer;

layout(binding = 0) readonly buffer Chunk {
    uint voxel_buffer[];
} chunk;

layout(binding = 1) readonly buffer BakedChunkBuffer {
    uint offset;
} baked_chunk_buffer;

layout(binding = 2) writeonly buffer BakedChunk {
    uint render_buffer[];
} baked_chunk;

shared uint tier2_region_state;

void main() {
    // initialize shared memory and then continue
    tier2_region_state = 0u;
    barrier();

    // calculate position offset of tier 1 region
    uvec3 pos_offset = gl_GlobalInvocationID << 2;

    // calculate offset of tier 2 region
    uint bake_tier2_region_offset = baked_chunk_buffer.offset + (gl_WorkGroupID.x | ((gl_WorkGroupID.z | (gl_WorkGroupID.y << 3u)) << 3u)) * 4161u;

    // calculate offset of current tier 1 region for invocation id
    uint bake_region_offset = bake_tier2_region_offset + 1u + (gl_LocalInvocationID.x | ((gl_LocalInvocationID.z | (gl_LocalInvocationID.y << 2u)) << 2u)) * 65u; //

    // init starting iteration index
    int bake_region_index = int(bake_region_offset) + 1;

    // one thread bakes 4x4x4 tier 1 voxel region
    bool any_voxel = false;
    // for (int i = 0; i < 100; i++)
    for (uint y = 0u; y < 4u; y++) {
        for (uint z = 0u; z < 4u; z++) {
            for (uint x = 0u; x < 4u; x++) {
                uvec3 voxel_pos = pos_offset + uvec3(x, y, z);
                uint voxel_index = voxel_pos.x | ((voxel_pos.z | (voxel_pos.y << 7)) << 7);
                uint voxel = chunk.voxel_buffer[voxel_index];
                if (voxel != 0u) {
                    any_voxel = true;
                }
                baked_chunk.render_buffer[bake_region_index] = voxel;
                bake_region_index++;
            }
        }
    }

    baked_chunk.render_buffer[bake_region_offset] = uint(any_voxel);
    baked_chunk.render_buffer[bake_tier2_region_offset] = atomicAdd(tier2_region_state, uint(any_voxel)) + uint(any_voxel);
}