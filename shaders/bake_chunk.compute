#version 310 es
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(std430) buffer;

layout(binding = 0) readonly buffer Chunk {
    uint voxel_buffer[];
} chunk;

layout(binding = 1) readonly buffer UniformData {
    uint data[];
} uniform_data;

layout(binding = 2) writeonly buffer BakedChunk {
    uint render_buffer[];
} baked_chunk;

shared uint tier2_region_state;

void main() {
    // initialize shared memory and then continue
    tier2_region_state = 0u;
    barrier();

    uint baked_buffer_offset = uniform_data.data[0];
    uvec3 dispatch_region_offset = uvec3(uniform_data.data[1], uniform_data.data[2], uniform_data.data[3]);

    // calculate position offset of tier 1 region
    uvec3 pos_offset = (gl_GlobalInvocationID << 2) + (dispatch_region_offset << 4);

    // calculate tier 2 position offset
    uvec3 pos_offset_tier2 = gl_WorkGroupID + dispatch_region_offset;

    // calculate offset of tier 2 region
    uint bake_tier2_region_offset = baked_buffer_offset + (pos_offset_tier2.x | ((pos_offset_tier2.z | (pos_offset_tier2.y << 3u)) << 3u)) * 4161u;

    // calculate offset of current tier 1 region for invocation id
    uint bake_region_offset = bake_tier2_region_offset + 1u + (gl_LocalInvocationID.x | ((gl_LocalInvocationID.z | (gl_LocalInvocationID.y << 2u)) << 2u)) * 65u; //

    // init starting iteration index
    int bake_region_index = int(bake_region_offset) + 1;

    // one thread bakes 4x4x4 tier 1 voxel region
    bool any_voxel = false;

    // for (int i = 0; i < 100; i++)
    for (uint y = 0u; y < 4u; y++) {
        for (uint z = 0u; z < 4u; z++) {
            for (uint x = 0u; x < 4u; x++) {
                uvec3 voxel_pos = pos_offset + uvec3(x, y, z);
                uint voxel_index = voxel_pos.x | ((voxel_pos.z | (voxel_pos.y << 7)) << 7);
                uint voxel = chunk.voxel_buffer[voxel_index];
                if (voxel != 0u) {
                    any_voxel = true;
                }
                baked_chunk.render_buffer[bake_region_index] = voxel;
                bake_region_index++;
            }
        }
    }

    baked_chunk.render_buffer[bake_region_offset] = uint(any_voxel);
    atomicAdd(tier2_region_state, uint(any_voxel));
    barrier();
    memoryBarrier();
    baked_chunk.render_buffer[bake_tier2_region_offset] = tier2_region_state;
}